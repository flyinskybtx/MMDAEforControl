!obj:pylearn2.train.Train {

    dataset: &train !obj:pylearn2.datasets.binarizer.Binarizer {
      raw: !obj:customRBM.CustomMMPosterior {
        which_set: "train",
        model_file1: %(goal_model)s,
        data_file1: %(goal_data)s,
        model_file2: %(cmdvel_model)s,
        data_file2: %(cmdvel_data)s,
        batch_size: %(batch_size)i,
        shuffle: True,
        start: 0,
        stop: 250000,
      }
    },

    model: !obj:pylearn2.models.dbm.DBM {

        batch_size: %(batch_size)i,

        # 1 mean field iteration reaches convergence in the RBM

        niter: 1, # what is this?

        visible_layer: !obj:pylearn2.models.dbm.BinaryVector {

            nvis: %(nvis)i,

            bias_from_marginals: *train

        },

        hidden_layers: [

            !obj:pylearn2.models.dbm.BinaryVectorMaxPool {

                layer_name: 'h',

                detector_layer_dim: %(hidden_layer_dim)i,

                pool_size: 1,

                irange: .05,

                init_bias: -2.,

            }

       ]

    },

    algorithm: !obj:pylearn2.training_algorithms.sgd.SGD {

               learning_rate: 1e-3,

               learning_rule: !obj:pylearn2.training_algorithms.learning_rule.Momentum {
                   init_momentum: 0.5,

               },

               monitoring_batches: %(monitoring_batches)i,

              monitoring_dataset : {
            'train' : *train,
            'valid' : !obj:customRBM.CustomMMPosterior {
                which_set: "train",
                model_file1: %(goal_model)s,
                data_file1: %(goal_data)s,
                model_file2: %(cmdvel_model)s,
                data_file2: %(cmdvel_data)s,
                batch_size: %(batch_size)i,
                shuffle: True,
                start: 250000,
                stop: 300000,
               },
               },
               monitoring_costs : {'mse':!obj:custom_monitor.monReconErr {}},
               cost : !obj:pylearn2.costs.cost.SumOfCosts {

                costs: [

                        # The first term of our cost function is variational PCD.
                        # For the RBM, the variational approximation is exact, so
                        # this is really just PCD. In deeper models, it means we
                        # use mean field rather than Gibbs sampling in the positive phase.

                        !obj:pylearn2.costs.dbm.VariationalPCD { # regular PCD

                           # Here we specify how many fantasy particles to maintain
                           num_chains: 100, # ???
                           # Here we specify how many steps of Gibbs sampling to do between
                           # each parameter update.
                           num_gibbs_steps: 5 # can this vary as training progresses

                        },

                        # The second term of our cost function is a little bit of weight
                        # decay.

                        !obj:pylearn2.costs.dbm.WeightDecay {

                          coeffs: [ .0001  ]

                        },

                        # Finally, we regularize the RBM to sparse, using a method copied
                        # from Ruslan Salakhutdinov's DBM demo

                        !obj:pylearn2.costs.dbm.TorontoSparsity {

                         targets: [ .2 ],
                         coeffs: [ .001 ],

                        }

                       ],

           },

           # alternate termination criteria?
           termination_criterion: !obj:pylearn2.termination_criteria.MonitorBased
               {
                        channel_name: "valid_mse",
                        N: 100,
                        prop_decrease: 0.

           },

           update_callbacks: [

                !obj:pylearn2.training_algorithms.sgd.ExponentialDecay {

                        decay_factor: 1.000015,
                        min_lr:       0.0001

                }

           ]

        },

    extensions: [
            !obj:pylearn2.train_extensions.best_params.MonitorBasedSaveBest {
                        channel_name: "valid_mse",
                        save_path: "%(save_path)s/%(type)s_%(goal_model_base)s_%(cmdvel_model_base)s_best.pkl"
                }

    ],

    save_path: "%(save_path)s/%(type)s_%(goal_model_base)s_%(cmdvel_model_base)s.pkl",

    save_freq : 1

}
